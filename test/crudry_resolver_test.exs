defmodule CrudryResolverTest do
  use ExUnit.Case
  doctest Crudry.Resolver

  alias CrudryTest.Test
  alias Crudry.Repo

  import Ecto.Query

  defmodule Users do
    alias Crudry.User

    require Crudry.Context
    alias Crudry.Context

    Context.generate_functions(User)
  end

  defmodule Companies do
    alias Crudry.Company

    require Crudry.Context
    alias Crudry.Context

    Context.generate_functions(Company)
  end

  defmodule Posts do
    alias Crudry.Post

    require Crudry.Context
    alias Crudry.Context

    Context.generate_functions(Post)
  end

  defmodule Context do
    alias CrudryTest.Repo
    alias CrudryTest.Test
    require Crudry.Context

    Crudry.Context.generate_functions(Test)
  end

  defmodule CamelizedContext do
    alias CrudryTest.Repo
    alias CrudryTest.CamelizedSchemaName
    require Crudry.Context

    Crudry.Context.generate_functions(CamelizedSchemaName)
  end

  @info %{}
  @userparams %{params: %{username: "test"}}

  test "creates the CRUD functions" do
    defmodule Resolver do
      Crudry.Resolver.generate_functions(Context, Test)
    end

    assert Resolver.get_test(%{id: 1}, @info) == {:ok, %Test{x: "123"}}
    assert Resolver.get_test(%{id: 0}, @info) == {:error, "Test not found."}
    assert Resolver.list_tests(%{}, @info) == {:ok, [1, 2, 3]}
    assert Resolver.create_test(%{params: %{x: 2}}, @info) == {:ok, %Test{x: 2}}
    assert Resolver.update_test(%{id: 3, params: %{x: 3}}, @info) == {:ok, %Test{x: 3}}
    assert Resolver.update_test(%{id: 0, params: %{x: 3}}, @info) == {:error, "Test not found."}
    assert Resolver.delete_test(%{id: 2}, @info) == {:ok, :deleted}
    assert Resolver.delete_test(%{id: 0}, @info) == {:error, "Test not found."}
  end

  test "choose which CRUD functions are to be generated" do
    defmodule ResolverOnly do
      Crudry.Resolver.generate_functions(Context, CrudryTest.Test, only: [:create, :list])
    end

    assert ResolverOnly.create_test(%{params: %{x: 2}}, @info) == {:ok, %Test{x: 2}}
    assert ResolverOnly.list_tests(%{}, @info) == {:ok, [1, 2, 3]}
    assert length(ResolverOnly.__info__(:functions)) == 4

    defmodule ResolverExcept do
      Crudry.Resolver.generate_functions(Context, CrudryTest.Test, except: [:list, :delete])
    end

    assert ResolverExcept.create_test(%{params: %{x: 2}}, @info) == {:ok, %Test{x: 2}}
    assert ResolverExcept.update_test(%{id: 3, params: %{x: 3}}, @info) == {:ok, %Test{x: 3}}
    assert length(ResolverExcept.__info__(:functions)) == 5
  end

  test "choose which CRUD functions are to be generated by default" do
    defmodule ResolverOnlyDefault do
      Crudry.Resolver.default(only: [:create, :list])
      Crudry.Resolver.generate_functions(Context, CrudryTest.Test)
    end

    assert ResolverOnlyDefault.create_test(%{params: %{x: 2}}, @info) == {:ok, %Test{x: 2}}
    assert ResolverOnlyDefault.list_tests(%{}, @info) == {:ok, [1, 2, 3]}
    assert length(ResolverOnlyDefault.__info__(:functions)) == 4

    defmodule ResolverExceptDefault do
      Crudry.Resolver.default(except: [:list, :delete])
      Crudry.Resolver.generate_functions(Context, CrudryTest.Test)
    end

    assert ResolverExceptDefault.create_test(%{params: %{x: 2}}, @info) == {:ok, %Test{x: 2}}

    assert ResolverExceptDefault.update_test(%{id: 3, params: %{x: 3}}, @info) ==
             {:ok, %Test{x: 3}}

    assert length(ResolverExceptDefault.__info__(:functions)) == 5
  end

  test "set default options for list" do
    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Repo)

    defmodule ResolverListOptionsDefault do
      Crudry.Resolver.default(list_opts: [order_by: :id, sorting_order: :desc])
      Crudry.Resolver.generate_functions(Users, User)
    end

    ResolverListOptionsDefault.create_user(@userparams, @info)
    ResolverListOptionsDefault.create_user(@userparams, @info)
    ResolverListOptionsDefault.create_user(@userparams, @info)
    ResolverListOptionsDefault.create_user(@userparams, @info)

    {:ok, user_list} = ResolverListOptionsDefault.list_users(%{}, @info)
    id_list = Enum.map(user_list, & &1.id)
    assert List.first(id_list) > List.last(id_list)
  end

  test "set options for list" do
    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Repo)

    defmodule ResolverListOptions do
      Crudry.Resolver.generate_functions(Users, User,
        list_opts: [order_by: :id, sorting_order: :asc]
      )

      Crudry.Resolver.generate_functions(Posts, Post, list_opts: [order_by: [:user_id, :title]])
    end

    ResolverListOptions.create_user(@userparams, @info)
    ResolverListOptions.create_user(@userparams, @info)
    ResolverListOptions.create_user(@userparams, @info)
    ResolverListOptions.create_user(@userparams, @info)

    {:ok, user_list} = ResolverListOptions.list_users(%{}, @info)

    first_user_id = List.first(user_list) |> Map.get(:id)
    last_user_id = List.last(user_list) |> Map.get(:id)
    first_post_title = "Post A"
    last_post_title = "Post B"

    ResolverListOptions.create_post(
      %{params: %{user_id: last_user_id, title: last_post_title}},
      @info
    )

    ResolverListOptions.create_post(
      %{params: %{user_id: last_user_id, title: first_post_title}},
      @info
    )

    ResolverListOptions.create_post(
      %{params: %{user_id: first_user_id, title: last_post_title}},
      @info
    )

    ResolverListOptions.create_post(
      %{params: %{user_id: first_user_id, title: first_post_title}},
      @info
    )

    {:ok, post_list} = ResolverListOptions.list_posts(%{}, @info)

    id_list = Enum.map(user_list, & &1.id)
    assert List.first(id_list) < List.last(id_list)

    assert [
             %{user_id: first_user_id, title: first_post_title},
             %{user_id: first_user_id, title: last_post_title},
             %{user_id: last_user_id, title: first_post_title},
             %{user_id: last_user_id, title: last_post_title}
           ] == Enum.map(post_list, &Map.take(&1, [:user_id, :title]))
  end

  test "create custom update using nil_to_error" do
    defmodule ResolverExceptUpdate do
      Crudry.Resolver.default(except: [:update])
      Crudry.Resolver.generate_functions(Context, CrudryTest.Test)

      def update_test(%{id: id, params: params}, _info) do
        Context.get_test(id)
        |> nil_to_error("test", fn record ->
          Context.update_test_with_assocs(record, params, [:assoc])
        end)
      end
    end

    assert ResolverExceptUpdate.update_test(%{id: 3, params: %{x: 3}}, @info) ==
             {:ok, %Test{x: 3, assocs: [:assoc]}}

    assert ResolverExceptUpdate.update_test(%{id: 0, params: %{x: 3}}, @info) ==
             {:error, "Test not found."}
  end

  test "Camelized name in error message" do
    defmodule CamelizedResolver do
      Crudry.Resolver.generate_functions(CamelizedContext, CrudryTest.CamelizedSchemaName)
    end

    assert CamelizedResolver.get_camelized_schema_name(%{id: 0}, @info) ==
             {:error, "CamelizedSchemaName not found."}
  end

  test "Generate only one nil_to_error function" do
    defmodule MultipleResolver do
      Crudry.Resolver.generate_functions(Context, Test)
      Crudry.Resolver.generate_functions(CamelizedContext, CrudryTest.CamelizedSchemaName)
    end

    # When multiplie nil_to_error functions are generated, a warning is raised.
    # Not sure how to test for warnings, so for now just let the test pass and check if there are no warnings manually.
    assert true
  end

  test "Custom query function in resolver list_opts and Crudry.Query.list/2 is called with correct arguments" do
    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Repo)

    first_post_title = "Post A"
    last_post_title = "Post B"

    {:ok, user1} = Users.create_user(%{username: "test"})
    {:ok, user2} = Users.create_user(%{username: "test2"})

    Posts.create_post(%{user_id: user1.id, title: first_post_title})
    Posts.create_post(%{user_id: user1.id, title: last_post_title})
    Posts.create_post(%{user_id: user2.id, title: last_post_title})
    Posts.create_post(%{user_id: user2.id, title: first_post_title})
    Posts.create_post(%{user_id: user2.id, title: last_post_title})

    defmodule PostResolver do

      import Ecto.Query

      def custom_query(initial_query, info_arg) do
        current_user = info_arg.context.current_user

        where(initial_query, [p], p.user_id == ^current_user.id)
      end

      Crudry.Resolver.generate_functions(Posts, Post,
        list_opts: [
          order_by: [:title],
          custom_query: &custom_query/2
        ]
      )
    end

    info = %{context: %{current_user: user2}}

    {:ok, resolver_post_list} = PostResolver.list_posts(%{}, info)

    assert [
      %{user_id: user2.id, title: first_post_title},
      %{user_id: user2.id, title: last_post_title},
      %{user_id: user2.id, title: last_post_title}
    ] == Enum.map(resolver_post_list, &Map.take(&1, [:user_id, :title]))

    custom_query = fn initial_query ->
      initial_query
      |> where([p], p.user_id == ^user1.id)
      |> order_by(desc: :title)
    end

    query_post_list =
      Crudry.Post
      |> Crudry.Query.list([custom_query: custom_query])
      |> Repo.all

    assert [
      %{user_id: user1.id, title: last_post_title},
      %{user_id: user1.id, title: first_post_title}
    ] == Enum.map(query_post_list, &Map.take(&1, [:user_id, :title]))
  end

  test "Custom create_resolver receives correct arguments" do
    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Repo)

    defmodule UserResolver do
      def create_resolver(context, schema_name, args, %{context: %{current_user: %{company_id: company_id}}}) do
        apply(context, :"create_#{schema_name}", [Map.put(args.params, :company_id, company_id)])
      end

      Crudry.Resolver.generate_functions(Users, User, create_resolver: &create_resolver/4)
    end

    {:ok, company} = Companies.create_company(%{name: "Nike"})
    {:ok, user} = Users.create_user(%{username: "test", company_id: company.id})
    info = %{context: %{current_user: user}}
    params = %{username: "Jonas"}

    {:ok, new_user} = UserResolver.create_user(%{params: params}, info)

    assert new_user.company_id == company.id
    assert new_user.username == params.username
  end
end
